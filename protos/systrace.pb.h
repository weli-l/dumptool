// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: systrace.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_systrace_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_systrace_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_systrace_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_systrace_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_systrace_2eproto;
namespace systrace {
namespace hook {
class GcDebugData;
struct GcDebugDataDefaultTypeInternal;
extern GcDebugDataDefaultTypeInternal _GcDebugData_default_instance_;
class Mem;
struct MemDefaultTypeInternal;
extern MemDefaultTypeInternal _Mem_default_instance_;
class MemAllocEntry;
struct MemAllocEntryDefaultTypeInternal;
extern MemAllocEntryDefaultTypeInternal _MemAllocEntry_default_instance_;
class MemFreeEntry;
struct MemFreeEntryDefaultTypeInternal;
extern MemFreeEntryDefaultTypeInternal _MemFreeEntry_default_instance_;
class ProcMem;
struct ProcMemDefaultTypeInternal;
extern ProcMemDefaultTypeInternal _ProcMem_default_instance_;
class Pytorch;
struct PytorchDefaultTypeInternal;
extern PytorchDefaultTypeInternal _Pytorch_default_instance_;
class PytorchStage;
struct PytorchStageDefaultTypeInternal;
extern PytorchStageDefaultTypeInternal _PytorchStage_default_instance_;
class StackFrame;
struct StackFrameDefaultTypeInternal;
extern StackFrameDefaultTypeInternal _StackFrame_default_instance_;
}  // namespace hook
}  // namespace systrace
PROTOBUF_NAMESPACE_OPEN
template<> ::systrace::hook::GcDebugData* Arena::CreateMaybeMessage<::systrace::hook::GcDebugData>(Arena*);
template<> ::systrace::hook::Mem* Arena::CreateMaybeMessage<::systrace::hook::Mem>(Arena*);
template<> ::systrace::hook::MemAllocEntry* Arena::CreateMaybeMessage<::systrace::hook::MemAllocEntry>(Arena*);
template<> ::systrace::hook::MemFreeEntry* Arena::CreateMaybeMessage<::systrace::hook::MemFreeEntry>(Arena*);
template<> ::systrace::hook::ProcMem* Arena::CreateMaybeMessage<::systrace::hook::ProcMem>(Arena*);
template<> ::systrace::hook::Pytorch* Arena::CreateMaybeMessage<::systrace::hook::Pytorch>(Arena*);
template<> ::systrace::hook::PytorchStage* Arena::CreateMaybeMessage<::systrace::hook::PytorchStage>(Arena*);
template<> ::systrace::hook::StackFrame* Arena::CreateMaybeMessage<::systrace::hook::StackFrame>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace systrace {
namespace hook {

enum StageType : int {
  STAGE_DATALOADER = 0,
  STAGE_FORWARD = 1,
  STAGE_BACKWARD = 2,
  StageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StageType_IsValid(int value);
constexpr StageType StageType_MIN = STAGE_DATALOADER;
constexpr StageType StageType_MAX = STAGE_BACKWARD;
constexpr int StageType_ARRAYSIZE = StageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StageType_descriptor();
template<typename T>
inline const std::string& StageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StageType_descriptor(), enum_t_value);
}
inline bool StageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StageType>(
    StageType_descriptor(), name, value);
}
// ===================================================================

class StackFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:systrace.hook.StackFrame) */ {
 public:
  inline StackFrame() : StackFrame(nullptr) {}
  ~StackFrame() override;
  explicit PROTOBUF_CONSTEXPR StackFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StackFrame(const StackFrame& from);
  StackFrame(StackFrame&& from) noexcept
    : StackFrame() {
    *this = ::std::move(from);
  }

  inline StackFrame& operator=(const StackFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline StackFrame& operator=(StackFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StackFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const StackFrame* internal_default_instance() {
    return reinterpret_cast<const StackFrame*>(
               &_StackFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StackFrame& a, StackFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(StackFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StackFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StackFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StackFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StackFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StackFrame& from) {
    StackFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StackFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "systrace.hook.StackFrame";
  }
  protected:
  explicit StackFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoNameFieldNumber = 2,
    kAddressFieldNumber = 1,
  };
  // string so_name = 2;
  void clear_so_name();
  const std::string& so_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_so_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_so_name();
  PROTOBUF_NODISCARD std::string* release_so_name();
  void set_allocated_so_name(std::string* so_name);
  private:
  const std::string& _internal_so_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_so_name(const std::string& value);
  std::string* _internal_mutable_so_name();
  public:

  // uint64 address = 1;
  void clear_address();
  uint64_t address() const;
  void set_address(uint64_t value);
  private:
  uint64_t _internal_address() const;
  void _internal_set_address(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:systrace.hook.StackFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr so_name_;
    uint64_t address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_systrace_2eproto;
};
// -------------------------------------------------------------------

class MemAllocEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:systrace.hook.MemAllocEntry) */ {
 public:
  inline MemAllocEntry() : MemAllocEntry(nullptr) {}
  ~MemAllocEntry() override;
  explicit PROTOBUF_CONSTEXPR MemAllocEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemAllocEntry(const MemAllocEntry& from);
  MemAllocEntry(MemAllocEntry&& from) noexcept
    : MemAllocEntry() {
    *this = ::std::move(from);
  }

  inline MemAllocEntry& operator=(const MemAllocEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemAllocEntry& operator=(MemAllocEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemAllocEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemAllocEntry* internal_default_instance() {
    return reinterpret_cast<const MemAllocEntry*>(
               &_MemAllocEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MemAllocEntry& a, MemAllocEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(MemAllocEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemAllocEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemAllocEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemAllocEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemAllocEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MemAllocEntry& from) {
    MemAllocEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemAllocEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "systrace.hook.MemAllocEntry";
  }
  protected:
  explicit MemAllocEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStackFramesFieldNumber = 4,
    kAllocPtrFieldNumber = 1,
    kMemSizeFieldNumber = 3,
    kStageIdFieldNumber = 2,
  };
  // repeated .systrace.hook.StackFrame stack_frames = 4;
  int stack_frames_size() const;
  private:
  int _internal_stack_frames_size() const;
  public:
  void clear_stack_frames();
  ::systrace::hook::StackFrame* mutable_stack_frames(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::StackFrame >*
      mutable_stack_frames();
  private:
  const ::systrace::hook::StackFrame& _internal_stack_frames(int index) const;
  ::systrace::hook::StackFrame* _internal_add_stack_frames();
  public:
  const ::systrace::hook::StackFrame& stack_frames(int index) const;
  ::systrace::hook::StackFrame* add_stack_frames();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::StackFrame >&
      stack_frames() const;

  // uint64 alloc_ptr = 1;
  void clear_alloc_ptr();
  uint64_t alloc_ptr() const;
  void set_alloc_ptr(uint64_t value);
  private:
  uint64_t _internal_alloc_ptr() const;
  void _internal_set_alloc_ptr(uint64_t value);
  public:

  // uint64 mem_size = 3;
  void clear_mem_size();
  uint64_t mem_size() const;
  void set_mem_size(uint64_t value);
  private:
  uint64_t _internal_mem_size() const;
  void _internal_set_mem_size(uint64_t value);
  public:

  // uint32 stage_id = 2;
  void clear_stage_id();
  uint32_t stage_id() const;
  void set_stage_id(uint32_t value);
  private:
  uint32_t _internal_stage_id() const;
  void _internal_set_stage_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:systrace.hook.MemAllocEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::StackFrame > stack_frames_;
    uint64_t alloc_ptr_;
    uint64_t mem_size_;
    uint32_t stage_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_systrace_2eproto;
};
// -------------------------------------------------------------------

class MemFreeEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:systrace.hook.MemFreeEntry) */ {
 public:
  inline MemFreeEntry() : MemFreeEntry(nullptr) {}
  ~MemFreeEntry() override;
  explicit PROTOBUF_CONSTEXPR MemFreeEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemFreeEntry(const MemFreeEntry& from);
  MemFreeEntry(MemFreeEntry&& from) noexcept
    : MemFreeEntry() {
    *this = ::std::move(from);
  }

  inline MemFreeEntry& operator=(const MemFreeEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemFreeEntry& operator=(MemFreeEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemFreeEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemFreeEntry* internal_default_instance() {
    return reinterpret_cast<const MemFreeEntry*>(
               &_MemFreeEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MemFreeEntry& a, MemFreeEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(MemFreeEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemFreeEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemFreeEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemFreeEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemFreeEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MemFreeEntry& from) {
    MemFreeEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemFreeEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "systrace.hook.MemFreeEntry";
  }
  protected:
  explicit MemFreeEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllocPtrFieldNumber = 1,
  };
  // uint64 alloc_ptr = 1;
  void clear_alloc_ptr();
  uint64_t alloc_ptr() const;
  void set_alloc_ptr(uint64_t value);
  private:
  uint64_t _internal_alloc_ptr() const;
  void _internal_set_alloc_ptr(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:systrace.hook.MemFreeEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t alloc_ptr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_systrace_2eproto;
};
// -------------------------------------------------------------------

class ProcMem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:systrace.hook.ProcMem) */ {
 public:
  inline ProcMem() : ProcMem(nullptr) {}
  ~ProcMem() override;
  explicit PROTOBUF_CONSTEXPR ProcMem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcMem(const ProcMem& from);
  ProcMem(ProcMem&& from) noexcept
    : ProcMem() {
    *this = ::std::move(from);
  }

  inline ProcMem& operator=(const ProcMem& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcMem& operator=(ProcMem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcMem& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcMem* internal_default_instance() {
    return reinterpret_cast<const ProcMem*>(
               &_ProcMem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ProcMem& a, ProcMem& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcMem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcMem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcMem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcMem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcMem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcMem& from) {
    ProcMem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcMem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "systrace.hook.ProcMem";
  }
  protected:
  explicit ProcMem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemAllocStacksFieldNumber = 2,
    kMemFreeStacksFieldNumber = 3,
    kPidFieldNumber = 1,
  };
  // repeated .systrace.hook.MemAllocEntry mem_alloc_stacks = 2;
  int mem_alloc_stacks_size() const;
  private:
  int _internal_mem_alloc_stacks_size() const;
  public:
  void clear_mem_alloc_stacks();
  ::systrace::hook::MemAllocEntry* mutable_mem_alloc_stacks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::MemAllocEntry >*
      mutable_mem_alloc_stacks();
  private:
  const ::systrace::hook::MemAllocEntry& _internal_mem_alloc_stacks(int index) const;
  ::systrace::hook::MemAllocEntry* _internal_add_mem_alloc_stacks();
  public:
  const ::systrace::hook::MemAllocEntry& mem_alloc_stacks(int index) const;
  ::systrace::hook::MemAllocEntry* add_mem_alloc_stacks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::MemAllocEntry >&
      mem_alloc_stacks() const;

  // repeated .systrace.hook.MemFreeEntry mem_free_stacks = 3;
  int mem_free_stacks_size() const;
  private:
  int _internal_mem_free_stacks_size() const;
  public:
  void clear_mem_free_stacks();
  ::systrace::hook::MemFreeEntry* mutable_mem_free_stacks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::MemFreeEntry >*
      mutable_mem_free_stacks();
  private:
  const ::systrace::hook::MemFreeEntry& _internal_mem_free_stacks(int index) const;
  ::systrace::hook::MemFreeEntry* _internal_add_mem_free_stacks();
  public:
  const ::systrace::hook::MemFreeEntry& mem_free_stacks(int index) const;
  ::systrace::hook::MemFreeEntry* add_mem_free_stacks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::MemFreeEntry >&
      mem_free_stacks() const;

  // uint32 pid = 1;
  void clear_pid();
  uint32_t pid() const;
  void set_pid(uint32_t value);
  private:
  uint32_t _internal_pid() const;
  void _internal_set_pid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:systrace.hook.ProcMem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::MemAllocEntry > mem_alloc_stacks_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::MemFreeEntry > mem_free_stacks_;
    uint32_t pid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_systrace_2eproto;
};
// -------------------------------------------------------------------

class GcDebugData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:systrace.hook.GcDebugData) */ {
 public:
  inline GcDebugData() : GcDebugData(nullptr) {}
  ~GcDebugData() override;
  explicit PROTOBUF_CONSTEXPR GcDebugData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GcDebugData(const GcDebugData& from);
  GcDebugData(GcDebugData&& from) noexcept
    : GcDebugData() {
    *this = ::std::move(from);
  }

  inline GcDebugData& operator=(const GcDebugData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GcDebugData& operator=(GcDebugData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GcDebugData& default_instance() {
    return *internal_default_instance();
  }
  static inline const GcDebugData* internal_default_instance() {
    return reinterpret_cast<const GcDebugData*>(
               &_GcDebugData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GcDebugData& a, GcDebugData& b) {
    a.Swap(&b);
  }
  inline void Swap(GcDebugData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GcDebugData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GcDebugData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GcDebugData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GcDebugData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GcDebugData& from) {
    GcDebugData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GcDebugData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "systrace.hook.GcDebugData";
  }
  protected:
  explicit GcDebugData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectedFieldNumber = 1,
    kUncollectableFieldNumber = 2,
  };
  // uint32 collected = 1;
  void clear_collected();
  uint32_t collected() const;
  void set_collected(uint32_t value);
  private:
  uint32_t _internal_collected() const;
  void _internal_set_collected(uint32_t value);
  public:

  // uint32 uncollectable = 2;
  void clear_uncollectable();
  uint32_t uncollectable() const;
  void set_uncollectable(uint32_t value);
  private:
  uint32_t _internal_uncollectable() const;
  void _internal_set_uncollectable(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:systrace.hook.GcDebugData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t collected_;
    uint32_t uncollectable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_systrace_2eproto;
};
// -------------------------------------------------------------------

class PytorchStage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:systrace.hook.PytorchStage) */ {
 public:
  inline PytorchStage() : PytorchStage(nullptr) {}
  ~PytorchStage() override;
  explicit PROTOBUF_CONSTEXPR PytorchStage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PytorchStage(const PytorchStage& from);
  PytorchStage(PytorchStage&& from) noexcept
    : PytorchStage() {
    *this = ::std::move(from);
  }

  inline PytorchStage& operator=(const PytorchStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PytorchStage& operator=(PytorchStage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PytorchStage& default_instance() {
    return *internal_default_instance();
  }
  enum DebugDataCase {
    kGcDebug = 6,
    DEBUG_DATA_NOT_SET = 0,
  };

  static inline const PytorchStage* internal_default_instance() {
    return reinterpret_cast<const PytorchStage*>(
               &_PytorchStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PytorchStage& a, PytorchStage& b) {
    a.Swap(&b);
  }
  inline void Swap(PytorchStage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PytorchStage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PytorchStage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PytorchStage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PytorchStage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PytorchStage& from) {
    PytorchStage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PytorchStage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "systrace.hook.PytorchStage";
  }
  protected:
  explicit PytorchStage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStackFramesFieldNumber = 5,
    kStageTypeFieldNumber = 2,
    kStartUsFieldNumber = 3,
    kEndUsFieldNumber = 4,
    kStageIdFieldNumber = 1,
    kGcDebugFieldNumber = 6,
  };
  // repeated string stack_frames = 5;
  int stack_frames_size() const;
  private:
  int _internal_stack_frames_size() const;
  public:
  void clear_stack_frames();
  const std::string& stack_frames(int index) const;
  std::string* mutable_stack_frames(int index);
  void set_stack_frames(int index, const std::string& value);
  void set_stack_frames(int index, std::string&& value);
  void set_stack_frames(int index, const char* value);
  void set_stack_frames(int index, const char* value, size_t size);
  std::string* add_stack_frames();
  void add_stack_frames(const std::string& value);
  void add_stack_frames(std::string&& value);
  void add_stack_frames(const char* value);
  void add_stack_frames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& stack_frames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_stack_frames();
  private:
  const std::string& _internal_stack_frames(int index) const;
  std::string* _internal_add_stack_frames();
  public:

  // string stage_type = 2;
  void clear_stage_type();
  const std::string& stage_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stage_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stage_type();
  PROTOBUF_NODISCARD std::string* release_stage_type();
  void set_allocated_stage_type(std::string* stage_type);
  private:
  const std::string& _internal_stage_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stage_type(const std::string& value);
  std::string* _internal_mutable_stage_type();
  public:

  // uint64 start_us = 3;
  void clear_start_us();
  uint64_t start_us() const;
  void set_start_us(uint64_t value);
  private:
  uint64_t _internal_start_us() const;
  void _internal_set_start_us(uint64_t value);
  public:

  // uint64 end_us = 4;
  void clear_end_us();
  uint64_t end_us() const;
  void set_end_us(uint64_t value);
  private:
  uint64_t _internal_end_us() const;
  void _internal_set_end_us(uint64_t value);
  public:

  // uint32 stage_id = 1;
  void clear_stage_id();
  uint32_t stage_id() const;
  void set_stage_id(uint32_t value);
  private:
  uint32_t _internal_stage_id() const;
  void _internal_set_stage_id(uint32_t value);
  public:

  // .systrace.hook.GcDebugData gc_debug = 6;
  bool has_gc_debug() const;
  private:
  bool _internal_has_gc_debug() const;
  public:
  void clear_gc_debug();
  const ::systrace::hook::GcDebugData& gc_debug() const;
  PROTOBUF_NODISCARD ::systrace::hook::GcDebugData* release_gc_debug();
  ::systrace::hook::GcDebugData* mutable_gc_debug();
  void set_allocated_gc_debug(::systrace::hook::GcDebugData* gc_debug);
  private:
  const ::systrace::hook::GcDebugData& _internal_gc_debug() const;
  ::systrace::hook::GcDebugData* _internal_mutable_gc_debug();
  public:
  void unsafe_arena_set_allocated_gc_debug(
      ::systrace::hook::GcDebugData* gc_debug);
  ::systrace::hook::GcDebugData* unsafe_arena_release_gc_debug();

  void clear_debug_data();
  DebugDataCase debug_data_case() const;
  // @@protoc_insertion_point(class_scope:systrace.hook.PytorchStage)
 private:
  class _Internal;
  void set_has_gc_debug();

  inline bool has_debug_data() const;
  inline void clear_has_debug_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> stack_frames_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stage_type_;
    uint64_t start_us_;
    uint64_t end_us_;
    uint32_t stage_id_;
    union DebugDataUnion {
      constexpr DebugDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::systrace::hook::GcDebugData* gc_debug_;
    } debug_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_systrace_2eproto;
};
// -------------------------------------------------------------------

class Pytorch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:systrace.hook.Pytorch) */ {
 public:
  inline Pytorch() : Pytorch(nullptr) {}
  ~Pytorch() override;
  explicit PROTOBUF_CONSTEXPR Pytorch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pytorch(const Pytorch& from);
  Pytorch(Pytorch&& from) noexcept
    : Pytorch() {
    *this = ::std::move(from);
  }

  inline Pytorch& operator=(const Pytorch& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pytorch& operator=(Pytorch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pytorch& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pytorch* internal_default_instance() {
    return reinterpret_cast<const Pytorch*>(
               &_Pytorch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Pytorch& a, Pytorch& b) {
    a.Swap(&b);
  }
  inline void Swap(Pytorch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pytorch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pytorch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pytorch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pytorch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pytorch& from) {
    Pytorch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pytorch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "systrace.hook.Pytorch";
  }
  protected:
  explicit Pytorch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPytorchStagesFieldNumber = 1,
    kCommFieldNumber = 4,
    kRankFieldNumber = 2,
    kStepIdFieldNumber = 3,
  };
  // repeated .systrace.hook.PytorchStage pytorch_stages = 1;
  int pytorch_stages_size() const;
  private:
  int _internal_pytorch_stages_size() const;
  public:
  void clear_pytorch_stages();
  ::systrace::hook::PytorchStage* mutable_pytorch_stages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::PytorchStage >*
      mutable_pytorch_stages();
  private:
  const ::systrace::hook::PytorchStage& _internal_pytorch_stages(int index) const;
  ::systrace::hook::PytorchStage* _internal_add_pytorch_stages();
  public:
  const ::systrace::hook::PytorchStage& pytorch_stages(int index) const;
  ::systrace::hook::PytorchStage* add_pytorch_stages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::PytorchStage >&
      pytorch_stages() const;

  // string comm = 4;
  void clear_comm();
  const std::string& comm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* comm);
  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(const std::string& value);
  std::string* _internal_mutable_comm();
  public:

  // uint32 rank = 2;
  void clear_rank();
  uint32_t rank() const;
  void set_rank(uint32_t value);
  private:
  uint32_t _internal_rank() const;
  void _internal_set_rank(uint32_t value);
  public:

  // uint32 step_id = 3;
  void clear_step_id();
  uint32_t step_id() const;
  void set_step_id(uint32_t value);
  private:
  uint32_t _internal_step_id() const;
  void _internal_set_step_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:systrace.hook.Pytorch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::PytorchStage > pytorch_stages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    uint32_t rank_;
    uint32_t step_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_systrace_2eproto;
};
// -------------------------------------------------------------------

class Mem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:systrace.hook.Mem) */ {
 public:
  inline Mem() : Mem(nullptr) {}
  ~Mem() override;
  explicit PROTOBUF_CONSTEXPR Mem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mem(const Mem& from);
  Mem(Mem&& from) noexcept
    : Mem() {
    *this = ::std::move(from);
  }

  inline Mem& operator=(const Mem& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mem& operator=(Mem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mem& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mem* internal_default_instance() {
    return reinterpret_cast<const Mem*>(
               &_Mem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Mem& a, Mem& b) {
    a.Swap(&b);
  }
  inline void Swap(Mem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mem& from) {
    Mem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "systrace.hook.Mem";
  }
  protected:
  explicit Mem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcMemFieldNumber = 1,
  };
  // repeated .systrace.hook.ProcMem proc_mem = 1;
  int proc_mem_size() const;
  private:
  int _internal_proc_mem_size() const;
  public:
  void clear_proc_mem();
  ::systrace::hook::ProcMem* mutable_proc_mem(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::ProcMem >*
      mutable_proc_mem();
  private:
  const ::systrace::hook::ProcMem& _internal_proc_mem(int index) const;
  ::systrace::hook::ProcMem* _internal_add_proc_mem();
  public:
  const ::systrace::hook::ProcMem& proc_mem(int index) const;
  ::systrace::hook::ProcMem* add_proc_mem();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::ProcMem >&
      proc_mem() const;

  // @@protoc_insertion_point(class_scope:systrace.hook.Mem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::ProcMem > proc_mem_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_systrace_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StackFrame

// uint64 address = 1;
inline void StackFrame::clear_address() {
  _impl_.address_ = uint64_t{0u};
}
inline uint64_t StackFrame::_internal_address() const {
  return _impl_.address_;
}
inline uint64_t StackFrame::address() const {
  // @@protoc_insertion_point(field_get:systrace.hook.StackFrame.address)
  return _internal_address();
}
inline void StackFrame::_internal_set_address(uint64_t value) {
  
  _impl_.address_ = value;
}
inline void StackFrame::set_address(uint64_t value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:systrace.hook.StackFrame.address)
}

// string so_name = 2;
inline void StackFrame::clear_so_name() {
  _impl_.so_name_.ClearToEmpty();
}
inline const std::string& StackFrame::so_name() const {
  // @@protoc_insertion_point(field_get:systrace.hook.StackFrame.so_name)
  return _internal_so_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StackFrame::set_so_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.so_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:systrace.hook.StackFrame.so_name)
}
inline std::string* StackFrame::mutable_so_name() {
  std::string* _s = _internal_mutable_so_name();
  // @@protoc_insertion_point(field_mutable:systrace.hook.StackFrame.so_name)
  return _s;
}
inline const std::string& StackFrame::_internal_so_name() const {
  return _impl_.so_name_.Get();
}
inline void StackFrame::_internal_set_so_name(const std::string& value) {
  
  _impl_.so_name_.Set(value, GetArenaForAllocation());
}
inline std::string* StackFrame::_internal_mutable_so_name() {
  
  return _impl_.so_name_.Mutable(GetArenaForAllocation());
}
inline std::string* StackFrame::release_so_name() {
  // @@protoc_insertion_point(field_release:systrace.hook.StackFrame.so_name)
  return _impl_.so_name_.Release();
}
inline void StackFrame::set_allocated_so_name(std::string* so_name) {
  if (so_name != nullptr) {
    
  } else {
    
  }
  _impl_.so_name_.SetAllocated(so_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.so_name_.IsDefault()) {
    _impl_.so_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:systrace.hook.StackFrame.so_name)
}

// -------------------------------------------------------------------

// MemAllocEntry

// uint64 alloc_ptr = 1;
inline void MemAllocEntry::clear_alloc_ptr() {
  _impl_.alloc_ptr_ = uint64_t{0u};
}
inline uint64_t MemAllocEntry::_internal_alloc_ptr() const {
  return _impl_.alloc_ptr_;
}
inline uint64_t MemAllocEntry::alloc_ptr() const {
  // @@protoc_insertion_point(field_get:systrace.hook.MemAllocEntry.alloc_ptr)
  return _internal_alloc_ptr();
}
inline void MemAllocEntry::_internal_set_alloc_ptr(uint64_t value) {
  
  _impl_.alloc_ptr_ = value;
}
inline void MemAllocEntry::set_alloc_ptr(uint64_t value) {
  _internal_set_alloc_ptr(value);
  // @@protoc_insertion_point(field_set:systrace.hook.MemAllocEntry.alloc_ptr)
}

// uint32 stage_id = 2;
inline void MemAllocEntry::clear_stage_id() {
  _impl_.stage_id_ = 0u;
}
inline uint32_t MemAllocEntry::_internal_stage_id() const {
  return _impl_.stage_id_;
}
inline uint32_t MemAllocEntry::stage_id() const {
  // @@protoc_insertion_point(field_get:systrace.hook.MemAllocEntry.stage_id)
  return _internal_stage_id();
}
inline void MemAllocEntry::_internal_set_stage_id(uint32_t value) {
  
  _impl_.stage_id_ = value;
}
inline void MemAllocEntry::set_stage_id(uint32_t value) {
  _internal_set_stage_id(value);
  // @@protoc_insertion_point(field_set:systrace.hook.MemAllocEntry.stage_id)
}

// uint64 mem_size = 3;
inline void MemAllocEntry::clear_mem_size() {
  _impl_.mem_size_ = uint64_t{0u};
}
inline uint64_t MemAllocEntry::_internal_mem_size() const {
  return _impl_.mem_size_;
}
inline uint64_t MemAllocEntry::mem_size() const {
  // @@protoc_insertion_point(field_get:systrace.hook.MemAllocEntry.mem_size)
  return _internal_mem_size();
}
inline void MemAllocEntry::_internal_set_mem_size(uint64_t value) {
  
  _impl_.mem_size_ = value;
}
inline void MemAllocEntry::set_mem_size(uint64_t value) {
  _internal_set_mem_size(value);
  // @@protoc_insertion_point(field_set:systrace.hook.MemAllocEntry.mem_size)
}

// repeated .systrace.hook.StackFrame stack_frames = 4;
inline int MemAllocEntry::_internal_stack_frames_size() const {
  return _impl_.stack_frames_.size();
}
inline int MemAllocEntry::stack_frames_size() const {
  return _internal_stack_frames_size();
}
inline void MemAllocEntry::clear_stack_frames() {
  _impl_.stack_frames_.Clear();
}
inline ::systrace::hook::StackFrame* MemAllocEntry::mutable_stack_frames(int index) {
  // @@protoc_insertion_point(field_mutable:systrace.hook.MemAllocEntry.stack_frames)
  return _impl_.stack_frames_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::StackFrame >*
MemAllocEntry::mutable_stack_frames() {
  // @@protoc_insertion_point(field_mutable_list:systrace.hook.MemAllocEntry.stack_frames)
  return &_impl_.stack_frames_;
}
inline const ::systrace::hook::StackFrame& MemAllocEntry::_internal_stack_frames(int index) const {
  return _impl_.stack_frames_.Get(index);
}
inline const ::systrace::hook::StackFrame& MemAllocEntry::stack_frames(int index) const {
  // @@protoc_insertion_point(field_get:systrace.hook.MemAllocEntry.stack_frames)
  return _internal_stack_frames(index);
}
inline ::systrace::hook::StackFrame* MemAllocEntry::_internal_add_stack_frames() {
  return _impl_.stack_frames_.Add();
}
inline ::systrace::hook::StackFrame* MemAllocEntry::add_stack_frames() {
  ::systrace::hook::StackFrame* _add = _internal_add_stack_frames();
  // @@protoc_insertion_point(field_add:systrace.hook.MemAllocEntry.stack_frames)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::StackFrame >&
MemAllocEntry::stack_frames() const {
  // @@protoc_insertion_point(field_list:systrace.hook.MemAllocEntry.stack_frames)
  return _impl_.stack_frames_;
}

// -------------------------------------------------------------------

// MemFreeEntry

// uint64 alloc_ptr = 1;
inline void MemFreeEntry::clear_alloc_ptr() {
  _impl_.alloc_ptr_ = uint64_t{0u};
}
inline uint64_t MemFreeEntry::_internal_alloc_ptr() const {
  return _impl_.alloc_ptr_;
}
inline uint64_t MemFreeEntry::alloc_ptr() const {
  // @@protoc_insertion_point(field_get:systrace.hook.MemFreeEntry.alloc_ptr)
  return _internal_alloc_ptr();
}
inline void MemFreeEntry::_internal_set_alloc_ptr(uint64_t value) {
  
  _impl_.alloc_ptr_ = value;
}
inline void MemFreeEntry::set_alloc_ptr(uint64_t value) {
  _internal_set_alloc_ptr(value);
  // @@protoc_insertion_point(field_set:systrace.hook.MemFreeEntry.alloc_ptr)
}

// -------------------------------------------------------------------

// ProcMem

// uint32 pid = 1;
inline void ProcMem::clear_pid() {
  _impl_.pid_ = 0u;
}
inline uint32_t ProcMem::_internal_pid() const {
  return _impl_.pid_;
}
inline uint32_t ProcMem::pid() const {
  // @@protoc_insertion_point(field_get:systrace.hook.ProcMem.pid)
  return _internal_pid();
}
inline void ProcMem::_internal_set_pid(uint32_t value) {
  
  _impl_.pid_ = value;
}
inline void ProcMem::set_pid(uint32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:systrace.hook.ProcMem.pid)
}

// repeated .systrace.hook.MemAllocEntry mem_alloc_stacks = 2;
inline int ProcMem::_internal_mem_alloc_stacks_size() const {
  return _impl_.mem_alloc_stacks_.size();
}
inline int ProcMem::mem_alloc_stacks_size() const {
  return _internal_mem_alloc_stacks_size();
}
inline void ProcMem::clear_mem_alloc_stacks() {
  _impl_.mem_alloc_stacks_.Clear();
}
inline ::systrace::hook::MemAllocEntry* ProcMem::mutable_mem_alloc_stacks(int index) {
  // @@protoc_insertion_point(field_mutable:systrace.hook.ProcMem.mem_alloc_stacks)
  return _impl_.mem_alloc_stacks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::MemAllocEntry >*
ProcMem::mutable_mem_alloc_stacks() {
  // @@protoc_insertion_point(field_mutable_list:systrace.hook.ProcMem.mem_alloc_stacks)
  return &_impl_.mem_alloc_stacks_;
}
inline const ::systrace::hook::MemAllocEntry& ProcMem::_internal_mem_alloc_stacks(int index) const {
  return _impl_.mem_alloc_stacks_.Get(index);
}
inline const ::systrace::hook::MemAllocEntry& ProcMem::mem_alloc_stacks(int index) const {
  // @@protoc_insertion_point(field_get:systrace.hook.ProcMem.mem_alloc_stacks)
  return _internal_mem_alloc_stacks(index);
}
inline ::systrace::hook::MemAllocEntry* ProcMem::_internal_add_mem_alloc_stacks() {
  return _impl_.mem_alloc_stacks_.Add();
}
inline ::systrace::hook::MemAllocEntry* ProcMem::add_mem_alloc_stacks() {
  ::systrace::hook::MemAllocEntry* _add = _internal_add_mem_alloc_stacks();
  // @@protoc_insertion_point(field_add:systrace.hook.ProcMem.mem_alloc_stacks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::MemAllocEntry >&
ProcMem::mem_alloc_stacks() const {
  // @@protoc_insertion_point(field_list:systrace.hook.ProcMem.mem_alloc_stacks)
  return _impl_.mem_alloc_stacks_;
}

// repeated .systrace.hook.MemFreeEntry mem_free_stacks = 3;
inline int ProcMem::_internal_mem_free_stacks_size() const {
  return _impl_.mem_free_stacks_.size();
}
inline int ProcMem::mem_free_stacks_size() const {
  return _internal_mem_free_stacks_size();
}
inline void ProcMem::clear_mem_free_stacks() {
  _impl_.mem_free_stacks_.Clear();
}
inline ::systrace::hook::MemFreeEntry* ProcMem::mutable_mem_free_stacks(int index) {
  // @@protoc_insertion_point(field_mutable:systrace.hook.ProcMem.mem_free_stacks)
  return _impl_.mem_free_stacks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::MemFreeEntry >*
ProcMem::mutable_mem_free_stacks() {
  // @@protoc_insertion_point(field_mutable_list:systrace.hook.ProcMem.mem_free_stacks)
  return &_impl_.mem_free_stacks_;
}
inline const ::systrace::hook::MemFreeEntry& ProcMem::_internal_mem_free_stacks(int index) const {
  return _impl_.mem_free_stacks_.Get(index);
}
inline const ::systrace::hook::MemFreeEntry& ProcMem::mem_free_stacks(int index) const {
  // @@protoc_insertion_point(field_get:systrace.hook.ProcMem.mem_free_stacks)
  return _internal_mem_free_stacks(index);
}
inline ::systrace::hook::MemFreeEntry* ProcMem::_internal_add_mem_free_stacks() {
  return _impl_.mem_free_stacks_.Add();
}
inline ::systrace::hook::MemFreeEntry* ProcMem::add_mem_free_stacks() {
  ::systrace::hook::MemFreeEntry* _add = _internal_add_mem_free_stacks();
  // @@protoc_insertion_point(field_add:systrace.hook.ProcMem.mem_free_stacks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::MemFreeEntry >&
ProcMem::mem_free_stacks() const {
  // @@protoc_insertion_point(field_list:systrace.hook.ProcMem.mem_free_stacks)
  return _impl_.mem_free_stacks_;
}

// -------------------------------------------------------------------

// GcDebugData

// uint32 collected = 1;
inline void GcDebugData::clear_collected() {
  _impl_.collected_ = 0u;
}
inline uint32_t GcDebugData::_internal_collected() const {
  return _impl_.collected_;
}
inline uint32_t GcDebugData::collected() const {
  // @@protoc_insertion_point(field_get:systrace.hook.GcDebugData.collected)
  return _internal_collected();
}
inline void GcDebugData::_internal_set_collected(uint32_t value) {
  
  _impl_.collected_ = value;
}
inline void GcDebugData::set_collected(uint32_t value) {
  _internal_set_collected(value);
  // @@protoc_insertion_point(field_set:systrace.hook.GcDebugData.collected)
}

// uint32 uncollectable = 2;
inline void GcDebugData::clear_uncollectable() {
  _impl_.uncollectable_ = 0u;
}
inline uint32_t GcDebugData::_internal_uncollectable() const {
  return _impl_.uncollectable_;
}
inline uint32_t GcDebugData::uncollectable() const {
  // @@protoc_insertion_point(field_get:systrace.hook.GcDebugData.uncollectable)
  return _internal_uncollectable();
}
inline void GcDebugData::_internal_set_uncollectable(uint32_t value) {
  
  _impl_.uncollectable_ = value;
}
inline void GcDebugData::set_uncollectable(uint32_t value) {
  _internal_set_uncollectable(value);
  // @@protoc_insertion_point(field_set:systrace.hook.GcDebugData.uncollectable)
}

// -------------------------------------------------------------------

// PytorchStage

// uint32 stage_id = 1;
inline void PytorchStage::clear_stage_id() {
  _impl_.stage_id_ = 0u;
}
inline uint32_t PytorchStage::_internal_stage_id() const {
  return _impl_.stage_id_;
}
inline uint32_t PytorchStage::stage_id() const {
  // @@protoc_insertion_point(field_get:systrace.hook.PytorchStage.stage_id)
  return _internal_stage_id();
}
inline void PytorchStage::_internal_set_stage_id(uint32_t value) {
  
  _impl_.stage_id_ = value;
}
inline void PytorchStage::set_stage_id(uint32_t value) {
  _internal_set_stage_id(value);
  // @@protoc_insertion_point(field_set:systrace.hook.PytorchStage.stage_id)
}

// string stage_type = 2;
inline void PytorchStage::clear_stage_type() {
  _impl_.stage_type_.ClearToEmpty();
}
inline const std::string& PytorchStage::stage_type() const {
  // @@protoc_insertion_point(field_get:systrace.hook.PytorchStage.stage_type)
  return _internal_stage_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PytorchStage::set_stage_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stage_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:systrace.hook.PytorchStage.stage_type)
}
inline std::string* PytorchStage::mutable_stage_type() {
  std::string* _s = _internal_mutable_stage_type();
  // @@protoc_insertion_point(field_mutable:systrace.hook.PytorchStage.stage_type)
  return _s;
}
inline const std::string& PytorchStage::_internal_stage_type() const {
  return _impl_.stage_type_.Get();
}
inline void PytorchStage::_internal_set_stage_type(const std::string& value) {
  
  _impl_.stage_type_.Set(value, GetArenaForAllocation());
}
inline std::string* PytorchStage::_internal_mutable_stage_type() {
  
  return _impl_.stage_type_.Mutable(GetArenaForAllocation());
}
inline std::string* PytorchStage::release_stage_type() {
  // @@protoc_insertion_point(field_release:systrace.hook.PytorchStage.stage_type)
  return _impl_.stage_type_.Release();
}
inline void PytorchStage::set_allocated_stage_type(std::string* stage_type) {
  if (stage_type != nullptr) {
    
  } else {
    
  }
  _impl_.stage_type_.SetAllocated(stage_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stage_type_.IsDefault()) {
    _impl_.stage_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:systrace.hook.PytorchStage.stage_type)
}

// uint64 start_us = 3;
inline void PytorchStage::clear_start_us() {
  _impl_.start_us_ = uint64_t{0u};
}
inline uint64_t PytorchStage::_internal_start_us() const {
  return _impl_.start_us_;
}
inline uint64_t PytorchStage::start_us() const {
  // @@protoc_insertion_point(field_get:systrace.hook.PytorchStage.start_us)
  return _internal_start_us();
}
inline void PytorchStage::_internal_set_start_us(uint64_t value) {
  
  _impl_.start_us_ = value;
}
inline void PytorchStage::set_start_us(uint64_t value) {
  _internal_set_start_us(value);
  // @@protoc_insertion_point(field_set:systrace.hook.PytorchStage.start_us)
}

// uint64 end_us = 4;
inline void PytorchStage::clear_end_us() {
  _impl_.end_us_ = uint64_t{0u};
}
inline uint64_t PytorchStage::_internal_end_us() const {
  return _impl_.end_us_;
}
inline uint64_t PytorchStage::end_us() const {
  // @@protoc_insertion_point(field_get:systrace.hook.PytorchStage.end_us)
  return _internal_end_us();
}
inline void PytorchStage::_internal_set_end_us(uint64_t value) {
  
  _impl_.end_us_ = value;
}
inline void PytorchStage::set_end_us(uint64_t value) {
  _internal_set_end_us(value);
  // @@protoc_insertion_point(field_set:systrace.hook.PytorchStage.end_us)
}

// repeated string stack_frames = 5;
inline int PytorchStage::_internal_stack_frames_size() const {
  return _impl_.stack_frames_.size();
}
inline int PytorchStage::stack_frames_size() const {
  return _internal_stack_frames_size();
}
inline void PytorchStage::clear_stack_frames() {
  _impl_.stack_frames_.Clear();
}
inline std::string* PytorchStage::add_stack_frames() {
  std::string* _s = _internal_add_stack_frames();
  // @@protoc_insertion_point(field_add_mutable:systrace.hook.PytorchStage.stack_frames)
  return _s;
}
inline const std::string& PytorchStage::_internal_stack_frames(int index) const {
  return _impl_.stack_frames_.Get(index);
}
inline const std::string& PytorchStage::stack_frames(int index) const {
  // @@protoc_insertion_point(field_get:systrace.hook.PytorchStage.stack_frames)
  return _internal_stack_frames(index);
}
inline std::string* PytorchStage::mutable_stack_frames(int index) {
  // @@protoc_insertion_point(field_mutable:systrace.hook.PytorchStage.stack_frames)
  return _impl_.stack_frames_.Mutable(index);
}
inline void PytorchStage::set_stack_frames(int index, const std::string& value) {
  _impl_.stack_frames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:systrace.hook.PytorchStage.stack_frames)
}
inline void PytorchStage::set_stack_frames(int index, std::string&& value) {
  _impl_.stack_frames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:systrace.hook.PytorchStage.stack_frames)
}
inline void PytorchStage::set_stack_frames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stack_frames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:systrace.hook.PytorchStage.stack_frames)
}
inline void PytorchStage::set_stack_frames(int index, const char* value, size_t size) {
  _impl_.stack_frames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:systrace.hook.PytorchStage.stack_frames)
}
inline std::string* PytorchStage::_internal_add_stack_frames() {
  return _impl_.stack_frames_.Add();
}
inline void PytorchStage::add_stack_frames(const std::string& value) {
  _impl_.stack_frames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:systrace.hook.PytorchStage.stack_frames)
}
inline void PytorchStage::add_stack_frames(std::string&& value) {
  _impl_.stack_frames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:systrace.hook.PytorchStage.stack_frames)
}
inline void PytorchStage::add_stack_frames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stack_frames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:systrace.hook.PytorchStage.stack_frames)
}
inline void PytorchStage::add_stack_frames(const char* value, size_t size) {
  _impl_.stack_frames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:systrace.hook.PytorchStage.stack_frames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PytorchStage::stack_frames() const {
  // @@protoc_insertion_point(field_list:systrace.hook.PytorchStage.stack_frames)
  return _impl_.stack_frames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PytorchStage::mutable_stack_frames() {
  // @@protoc_insertion_point(field_mutable_list:systrace.hook.PytorchStage.stack_frames)
  return &_impl_.stack_frames_;
}

// .systrace.hook.GcDebugData gc_debug = 6;
inline bool PytorchStage::_internal_has_gc_debug() const {
  return debug_data_case() == kGcDebug;
}
inline bool PytorchStage::has_gc_debug() const {
  return _internal_has_gc_debug();
}
inline void PytorchStage::set_has_gc_debug() {
  _impl_._oneof_case_[0] = kGcDebug;
}
inline void PytorchStage::clear_gc_debug() {
  if (_internal_has_gc_debug()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.debug_data_.gc_debug_;
    }
    clear_has_debug_data();
  }
}
inline ::systrace::hook::GcDebugData* PytorchStage::release_gc_debug() {
  // @@protoc_insertion_point(field_release:systrace.hook.PytorchStage.gc_debug)
  if (_internal_has_gc_debug()) {
    clear_has_debug_data();
    ::systrace::hook::GcDebugData* temp = _impl_.debug_data_.gc_debug_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.debug_data_.gc_debug_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::systrace::hook::GcDebugData& PytorchStage::_internal_gc_debug() const {
  return _internal_has_gc_debug()
      ? *_impl_.debug_data_.gc_debug_
      : reinterpret_cast< ::systrace::hook::GcDebugData&>(::systrace::hook::_GcDebugData_default_instance_);
}
inline const ::systrace::hook::GcDebugData& PytorchStage::gc_debug() const {
  // @@protoc_insertion_point(field_get:systrace.hook.PytorchStage.gc_debug)
  return _internal_gc_debug();
}
inline ::systrace::hook::GcDebugData* PytorchStage::unsafe_arena_release_gc_debug() {
  // @@protoc_insertion_point(field_unsafe_arena_release:systrace.hook.PytorchStage.gc_debug)
  if (_internal_has_gc_debug()) {
    clear_has_debug_data();
    ::systrace::hook::GcDebugData* temp = _impl_.debug_data_.gc_debug_;
    _impl_.debug_data_.gc_debug_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PytorchStage::unsafe_arena_set_allocated_gc_debug(::systrace::hook::GcDebugData* gc_debug) {
  clear_debug_data();
  if (gc_debug) {
    set_has_gc_debug();
    _impl_.debug_data_.gc_debug_ = gc_debug;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:systrace.hook.PytorchStage.gc_debug)
}
inline ::systrace::hook::GcDebugData* PytorchStage::_internal_mutable_gc_debug() {
  if (!_internal_has_gc_debug()) {
    clear_debug_data();
    set_has_gc_debug();
    _impl_.debug_data_.gc_debug_ = CreateMaybeMessage< ::systrace::hook::GcDebugData >(GetArenaForAllocation());
  }
  return _impl_.debug_data_.gc_debug_;
}
inline ::systrace::hook::GcDebugData* PytorchStage::mutable_gc_debug() {
  ::systrace::hook::GcDebugData* _msg = _internal_mutable_gc_debug();
  // @@protoc_insertion_point(field_mutable:systrace.hook.PytorchStage.gc_debug)
  return _msg;
}

inline bool PytorchStage::has_debug_data() const {
  return debug_data_case() != DEBUG_DATA_NOT_SET;
}
inline void PytorchStage::clear_has_debug_data() {
  _impl_._oneof_case_[0] = DEBUG_DATA_NOT_SET;
}
inline PytorchStage::DebugDataCase PytorchStage::debug_data_case() const {
  return PytorchStage::DebugDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Pytorch

// repeated .systrace.hook.PytorchStage pytorch_stages = 1;
inline int Pytorch::_internal_pytorch_stages_size() const {
  return _impl_.pytorch_stages_.size();
}
inline int Pytorch::pytorch_stages_size() const {
  return _internal_pytorch_stages_size();
}
inline void Pytorch::clear_pytorch_stages() {
  _impl_.pytorch_stages_.Clear();
}
inline ::systrace::hook::PytorchStage* Pytorch::mutable_pytorch_stages(int index) {
  // @@protoc_insertion_point(field_mutable:systrace.hook.Pytorch.pytorch_stages)
  return _impl_.pytorch_stages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::PytorchStage >*
Pytorch::mutable_pytorch_stages() {
  // @@protoc_insertion_point(field_mutable_list:systrace.hook.Pytorch.pytorch_stages)
  return &_impl_.pytorch_stages_;
}
inline const ::systrace::hook::PytorchStage& Pytorch::_internal_pytorch_stages(int index) const {
  return _impl_.pytorch_stages_.Get(index);
}
inline const ::systrace::hook::PytorchStage& Pytorch::pytorch_stages(int index) const {
  // @@protoc_insertion_point(field_get:systrace.hook.Pytorch.pytorch_stages)
  return _internal_pytorch_stages(index);
}
inline ::systrace::hook::PytorchStage* Pytorch::_internal_add_pytorch_stages() {
  return _impl_.pytorch_stages_.Add();
}
inline ::systrace::hook::PytorchStage* Pytorch::add_pytorch_stages() {
  ::systrace::hook::PytorchStage* _add = _internal_add_pytorch_stages();
  // @@protoc_insertion_point(field_add:systrace.hook.Pytorch.pytorch_stages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::PytorchStage >&
Pytorch::pytorch_stages() const {
  // @@protoc_insertion_point(field_list:systrace.hook.Pytorch.pytorch_stages)
  return _impl_.pytorch_stages_;
}

// uint32 rank = 2;
inline void Pytorch::clear_rank() {
  _impl_.rank_ = 0u;
}
inline uint32_t Pytorch::_internal_rank() const {
  return _impl_.rank_;
}
inline uint32_t Pytorch::rank() const {
  // @@protoc_insertion_point(field_get:systrace.hook.Pytorch.rank)
  return _internal_rank();
}
inline void Pytorch::_internal_set_rank(uint32_t value) {
  
  _impl_.rank_ = value;
}
inline void Pytorch::set_rank(uint32_t value) {
  _internal_set_rank(value);
  // @@protoc_insertion_point(field_set:systrace.hook.Pytorch.rank)
}

// uint32 step_id = 3;
inline void Pytorch::clear_step_id() {
  _impl_.step_id_ = 0u;
}
inline uint32_t Pytorch::_internal_step_id() const {
  return _impl_.step_id_;
}
inline uint32_t Pytorch::step_id() const {
  // @@protoc_insertion_point(field_get:systrace.hook.Pytorch.step_id)
  return _internal_step_id();
}
inline void Pytorch::_internal_set_step_id(uint32_t value) {
  
  _impl_.step_id_ = value;
}
inline void Pytorch::set_step_id(uint32_t value) {
  _internal_set_step_id(value);
  // @@protoc_insertion_point(field_set:systrace.hook.Pytorch.step_id)
}

// string comm = 4;
inline void Pytorch::clear_comm() {
  _impl_.comm_.ClearToEmpty();
}
inline const std::string& Pytorch::comm() const {
  // @@protoc_insertion_point(field_get:systrace.hook.Pytorch.comm)
  return _internal_comm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pytorch::set_comm(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:systrace.hook.Pytorch.comm)
}
inline std::string* Pytorch::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:systrace.hook.Pytorch.comm)
  return _s;
}
inline const std::string& Pytorch::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void Pytorch::_internal_set_comm(const std::string& value) {
  
  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* Pytorch::_internal_mutable_comm() {
  
  return _impl_.comm_.Mutable(GetArenaForAllocation());
}
inline std::string* Pytorch::release_comm() {
  // @@protoc_insertion_point(field_release:systrace.hook.Pytorch.comm)
  return _impl_.comm_.Release();
}
inline void Pytorch::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    
  } else {
    
  }
  _impl_.comm_.SetAllocated(comm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:systrace.hook.Pytorch.comm)
}

// -------------------------------------------------------------------

// Mem

// repeated .systrace.hook.ProcMem proc_mem = 1;
inline int Mem::_internal_proc_mem_size() const {
  return _impl_.proc_mem_.size();
}
inline int Mem::proc_mem_size() const {
  return _internal_proc_mem_size();
}
inline void Mem::clear_proc_mem() {
  _impl_.proc_mem_.Clear();
}
inline ::systrace::hook::ProcMem* Mem::mutable_proc_mem(int index) {
  // @@protoc_insertion_point(field_mutable:systrace.hook.Mem.proc_mem)
  return _impl_.proc_mem_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::ProcMem >*
Mem::mutable_proc_mem() {
  // @@protoc_insertion_point(field_mutable_list:systrace.hook.Mem.proc_mem)
  return &_impl_.proc_mem_;
}
inline const ::systrace::hook::ProcMem& Mem::_internal_proc_mem(int index) const {
  return _impl_.proc_mem_.Get(index);
}
inline const ::systrace::hook::ProcMem& Mem::proc_mem(int index) const {
  // @@protoc_insertion_point(field_get:systrace.hook.Mem.proc_mem)
  return _internal_proc_mem(index);
}
inline ::systrace::hook::ProcMem* Mem::_internal_add_proc_mem() {
  return _impl_.proc_mem_.Add();
}
inline ::systrace::hook::ProcMem* Mem::add_proc_mem() {
  ::systrace::hook::ProcMem* _add = _internal_add_proc_mem();
  // @@protoc_insertion_point(field_add:systrace.hook.Mem.proc_mem)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::systrace::hook::ProcMem >&
Mem::proc_mem() const {
  // @@protoc_insertion_point(field_list:systrace.hook.Mem.proc_mem)
  return _impl_.proc_mem_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hook
}  // namespace systrace

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::systrace::hook::StageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::systrace::hook::StageType>() {
  return ::systrace::hook::StageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_systrace_2eproto
